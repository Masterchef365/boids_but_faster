#version 450
layout (local_size_x = 16) in;

#include "shared.glsl"

struct Group {
    vec4 center;
    vec4 heading;
};

layout(std430, binding = 0) buffer Groups {
    Group groups[];
};

layout(std430, binding = 1) buffer Boids {
    Boid boids[];
};

layout(std430, push_constant) uniform Params {
    uint n_groups;
    float speed; // 0.004
    float dist_thresh; // 5.0
    float cohere; // 0.5
    float steer; // 0.12
    float parallel; // 0.12
};

void main() {
    uint gid = gl_GlobalInvocationID.x;
    if (gid >= boids.length()) return;

    vec3 avg_off = vec3(0);
    vec3 avg_heading = vec3(0);
    float avg_dist = 0.;
    uint total = 0;
    for (int g = 0; g < n_groups; g++) {
        vec3 off = boids[gid].pos - groups[g].center.xyz;
        float dist = length(off);
        if (dist < dist_thresh) {
            float dist_sq = dist * dist;
            avg_off += normalize(off) / dist_sq;
            avg_heading += normalize(groups[g].heading.xyz) / dist_sq;
            avg_dist += dist;
            total += 1;
        }
    }

    if (total > 0) {
        avg_off = normalize(avg_off);
        avg_heading = normalize(avg_heading);
        avg_dist /= float(total);

        float cohere_factor = clamp(cohere - avg_dist, 0., 1.);
        vec3 away = cross(boids[gid].heading.xyz, avg_off);
        vec3 cohere_head = mix(-avg_off, away, cohere_factor);

        vec3 new_heading = normalize(
            boids[gid].heading + 
            cohere_head * steer +
            avg_heading * parallel
        );

        if (!any(isnan(new_heading))) {
            boids[gid].heading = new_heading;
        }
    }

    boids[gid].pos += boids[gid].heading * speed;
}


